{"version":3,"file":"shallow.js","sources":["../src/vanilla/shallow.ts"],"sourcesContent":["const isIterable = (obj: object): obj is Iterable<unknown> =>\r\n  Symbol.iterator in obj\r\n\r\nconst hasIterableEntries = (\r\n  value: Iterable<unknown>,\r\n): value is Iterable<unknown> & {\r\n  entries(): Iterable<[unknown, unknown]>\r\n} =>\r\n  // HACK: avoid checking entries type\r\n  'entries' in value\r\n\r\nconst compareEntries = (\r\n  valueA: { entries(): Iterable<[unknown, unknown]> },\r\n  valueB: { entries(): Iterable<[unknown, unknown]> },\r\n) => {\r\n  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries())\r\n  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries())\r\n  if (mapA.size !== mapB.size) {\r\n    return false\r\n  }\r\n  for (const [key, value] of mapA) {\r\n    if (!mapB.has(key) || !Object.is(value, mapB.get(key))) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\n// Ordered iterables\r\nconst compareIterables = (\r\n  valueA: Iterable<unknown>,\r\n  valueB: Iterable<unknown>,\r\n) => {\r\n  const iteratorA = valueA[Symbol.iterator]()\r\n  const iteratorB = valueB[Symbol.iterator]()\r\n  let nextA = iteratorA.next()\r\n  let nextB = iteratorB.next()\r\n  while (!nextA.done && !nextB.done) {\r\n    if (!Object.is(nextA.value, nextB.value)) {\r\n      return false\r\n    }\r\n    nextA = iteratorA.next()\r\n    nextB = iteratorB.next()\r\n  }\r\n  return !!nextA.done && !!nextB.done\r\n}\r\n\r\nexport function shallow<T>(valueA: T, valueB: T): boolean {\r\n  if (Object.is(valueA, valueB)) {\r\n    return true\r\n  }\r\n  if (\r\n    typeof valueA !== 'object' ||\r\n    valueA === null ||\r\n    typeof valueB !== 'object' ||\r\n    valueB === null\r\n  ) {\r\n    return false\r\n  }\r\n  if (Object.getPrototypeOf(valueA) !== Object.getPrototypeOf(valueB)) {\r\n    return false\r\n  }\r\n  if (isIterable(valueA) && isIterable(valueB)) {\r\n    if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {\r\n      return compareEntries(valueA, valueB)\r\n    }\r\n    return compareIterables(valueA, valueB)\r\n  }\r\n  // assume plain objects\r\n  return compareEntries(\r\n    { entries: () => Object.entries(valueA) },\r\n    { entries: () => Object.entries(valueB) },\r\n  )\r\n}\r\n"],"names":[],"mappings":"AAAA,MAAM,aAAa,CAAC,QAClB,OAAO,YAAY;AAErB,MAAM,qBAAqB,CACzB;AAAA;AAAA,EAKA,aAAa;AAAA;AAEf,MAAM,iBAAiB,CACrB,QACA,WACG;AACH,QAAM,OAAO,kBAAkB,MAAM,SAAS,IAAI,IAAI,OAAO,SAAS;AACtE,QAAM,OAAO,kBAAkB,MAAM,SAAS,IAAI,IAAI,OAAO,SAAS;AACtE,MAAI,KAAK,SAAS,KAAK,MAAM;AAC3B,WAAO;AAAA,EACT;AACA,aAAW,CAAC,KAAK,KAAK,KAAK,MAAM;AAC/B,QAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,OAAO,GAAG,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG;AACtD,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAGA,MAAM,mBAAmB,CACvB,QACA,WACG;AACH,QAAM,YAAY,OAAO,OAAO,QAAQ,EAAA;AACxC,QAAM,YAAY,OAAO,OAAO,QAAQ,EAAA;AACxC,MAAI,QAAQ,UAAU,KAAA;AACtB,MAAI,QAAQ,UAAU,KAAA;AACtB,SAAO,CAAC,MAAM,QAAQ,CAAC,MAAM,MAAM;AACjC,QAAI,CAAC,OAAO,GAAG,MAAM,OAAO,MAAM,KAAK,GAAG;AACxC,aAAO;AAAA,IACT;AACA,YAAQ,UAAU,KAAA;AAClB,YAAQ,UAAU,KAAA;AAAA,EACpB;AACA,SAAO,CAAC,CAAC,MAAM,QAAQ,CAAC,CAAC,MAAM;AACjC;AAEO,SAAS,QAAW,QAAW,QAAoB;AACxD,MAAI,OAAO,GAAG,QAAQ,MAAM,GAAG;AAC7B,WAAO;AAAA,EACT;AACA,MACE,OAAO,WAAW,YAClB,WAAW,QACX,OAAO,WAAW,YAClB,WAAW,MACX;AACA,WAAO;AAAA,EACT;AACA,MAAI,OAAO,eAAe,MAAM,MAAM,OAAO,eAAe,MAAM,GAAG;AACnE,WAAO;AAAA,EACT;AACA,MAAI,WAAW,MAAM,KAAK,WAAW,MAAM,GAAG;AAC5C,QAAI,mBAAmB,MAAM,KAAK,mBAAmB,MAAM,GAAG;AAC5D,aAAO,eAAe,QAAQ,MAAM;AAAA,IACtC;AACA,WAAO,iBAAiB,QAAQ,MAAM;AAAA,EACxC;AAEA,SAAO;AAAA,IACL,EAAE,SAAS,MAAM,OAAO,QAAQ,MAAM,EAAA;AAAA,IACtC,EAAE,SAAS,MAAM,OAAO,QAAQ,MAAM,EAAA;AAAA,EAAE;AAE5C;"}