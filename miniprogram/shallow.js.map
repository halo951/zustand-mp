{"version":3,"file":"shallow.js","sources":["../src/vanilla/shallow.ts"],"sourcesContent":["const isIterable = (obj: object): obj is Iterable<unknown> => Symbol.iterator in obj\r\n\r\nconst hasIterableEntries = (\r\n    value: Iterable<unknown>\r\n): value is Iterable<unknown> & {\r\n    entries(): Iterable<[unknown, unknown]>\r\n} =>\r\n    // HACK: avoid checking entries type\r\n    'entries' in value\r\n\r\nconst compareEntries = (\r\n    valueA: { entries(): Iterable<[unknown, unknown]> },\r\n    valueB: { entries(): Iterable<[unknown, unknown]> }\r\n) => {\r\n    const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries())\r\n    const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries())\r\n    if (mapA.size !== mapB.size) {\r\n        return false\r\n    }\r\n    for (const [key, value] of mapA) {\r\n        if (!mapB.has(key) || !Object.is(value, mapB.get(key))) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\n// Ordered iterables\r\nconst compareIterables = (valueA: Iterable<unknown>, valueB: Iterable<unknown>) => {\r\n    const iteratorA = valueA[Symbol.iterator]()\r\n    const iteratorB = valueB[Symbol.iterator]()\r\n    let nextA = iteratorA.next()\r\n    let nextB = iteratorB.next()\r\n    while (!nextA.done && !nextB.done) {\r\n        if (!Object.is(nextA.value, nextB.value)) {\r\n            return false\r\n        }\r\n        nextA = iteratorA.next()\r\n        nextB = iteratorB.next()\r\n    }\r\n    return !!nextA.done && !!nextB.done\r\n}\r\n\r\nexport function shallow<T>(valueA: T, valueB: T): boolean {\r\n    if (Object.is(valueA, valueB)) {\r\n        return true\r\n    }\r\n    if (typeof valueA !== 'object' || valueA === null || typeof valueB !== 'object' || valueB === null) {\r\n        return false\r\n    }\r\n    if (Object.getPrototypeOf(valueA) !== Object.getPrototypeOf(valueB)) {\r\n        return false\r\n    }\r\n    if (isIterable(valueA) && isIterable(valueB)) {\r\n        if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {\r\n            return compareEntries(valueA, valueB)\r\n        }\r\n        return compareIterables(valueA, valueB)\r\n    }\r\n    // assume plain objects\r\n    return compareEntries({ entries: () => Object.entries(valueA) }, { entries: () => Object.entries(valueB) })\r\n}\r\n"],"names":[],"mappings":";;AAAA,MAAM,aAAa,CAAC,QAA0C,OAAO,YAAY;AAEjF,MAAM,qBAAqB,CACvB;AAAA;AAAA,EAKA,aAAa;AAAA;AAEjB,MAAM,iBAAiB,CACnB,QACA,WACC;AACD,QAAM,OAAO,kBAAkB,MAAM,SAAS,IAAI,IAAI,OAAO,SAAS;AACtE,QAAM,OAAO,kBAAkB,MAAM,SAAS,IAAI,IAAI,OAAO,SAAS;AACtE,MAAI,KAAK,SAAS,KAAK,MAAM;AACzB,WAAO;AAAA,EACX;AACA,aAAW,CAAC,KAAK,KAAK,KAAK,MAAM;AAC7B,QAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,OAAO,GAAG,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG;AACpD,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAGA,MAAM,mBAAmB,CAAC,QAA2B,WAA8B;AAC/E,QAAM,YAAY,OAAO,OAAO,QAAQ,EAAA;AACxC,QAAM,YAAY,OAAO,OAAO,QAAQ,EAAA;AACxC,MAAI,QAAQ,UAAU,KAAA;AACtB,MAAI,QAAQ,UAAU,KAAA;AACtB,SAAO,CAAC,MAAM,QAAQ,CAAC,MAAM,MAAM;AAC/B,QAAI,CAAC,OAAO,GAAG,MAAM,OAAO,MAAM,KAAK,GAAG;AACtC,aAAO;AAAA,IACX;AACA,YAAQ,UAAU,KAAA;AAClB,YAAQ,UAAU,KAAA;AAAA,EACtB;AACA,SAAO,CAAC,CAAC,MAAM,QAAQ,CAAC,CAAC,MAAM;AACnC;AAEO,SAAS,QAAW,QAAW,QAAoB;AACtD,MAAI,OAAO,GAAG,QAAQ,MAAM,GAAG;AAC3B,WAAO;AAAA,EACX;AACA,MAAI,OAAO,WAAW,YAAY,WAAW,QAAQ,OAAO,WAAW,YAAY,WAAW,MAAM;AAChG,WAAO;AAAA,EACX;AACA,MAAI,OAAO,eAAe,MAAM,MAAM,OAAO,eAAe,MAAM,GAAG;AACjE,WAAO;AAAA,EACX;AACA,MAAI,WAAW,MAAM,KAAK,WAAW,MAAM,GAAG;AAC1C,QAAI,mBAAmB,MAAM,KAAK,mBAAmB,MAAM,GAAG;AAC1D,aAAO,eAAe,QAAQ,MAAM;AAAA,IACxC;AACA,WAAO,iBAAiB,QAAQ,MAAM;AAAA,EAC1C;AAEA,SAAO,eAAe,EAAE,SAAS,MAAM,OAAO,QAAQ,MAAM,KAAK,EAAE,SAAS,MAAM,OAAO,QAAQ,MAAM,GAAG;AAC9G;;"}