{"version":3,"file":"middleware.js","sources":["../src/middleware/combine.ts","../src/middleware/persist.ts"],"sourcesContent":["import type { StateCreator, StoreMutatorIdentifier } from '../vanilla.ts'\r\n\r\ntype Write<T, U> = Omit<T, keyof U> & U\r\n\r\nexport function combine<\r\n    T extends object,\r\n    U extends object,\r\n    Mps extends [StoreMutatorIdentifier, unknown][] = [],\r\n    Mcs extends [StoreMutatorIdentifier, unknown][] = []\r\n>(initialState: T, create: StateCreator<T, Mps, Mcs, U>): StateCreator<Write<T, U>, Mps, Mcs> {\r\n    return (...args) => Object.assign({}, initialState, (create as any)(...args))\r\n}\r\n","import type { StateCreator, StoreApi, StoreMutatorIdentifier } from '../vanilla.ts'\r\n\r\nexport interface StateStorage<R = unknown> {\r\n    getItem: (name: string) => string | null | Promise<string | null>\r\n    setItem: (name: string, value: string) => R\r\n    removeItem: (name: string) => R\r\n}\r\n\r\nexport type StorageValue<S> = {\r\n    state: S\r\n    version?: number\r\n}\r\n\r\nexport interface PersistStorage<S, R = unknown> {\r\n    getItem: (name: string) => StorageValue<S> | null | Promise<StorageValue<S> | null>\r\n    setItem: (name: string, value: StorageValue<S>) => R\r\n    removeItem: (name: string) => R\r\n}\r\n\r\ntype JsonStorageOptions = {\r\n    reviver?: (key: string, value: unknown) => unknown\r\n    replacer?: (key: string, value: unknown) => unknown\r\n}\r\n\r\nexport function createJSONStorage<S, R = unknown>(\r\n    getStorage: () => StateStorage<R>,\r\n    options?: JsonStorageOptions\r\n): PersistStorage<S, unknown> | undefined {\r\n    let storage: StateStorage<R> | undefined\r\n    try {\r\n        storage = getStorage()\r\n    } catch {\r\n        // prevent error if the storage is not defined (e.g. when server side rendering a page)\r\n        return\r\n    }\r\n    const persistStorage: PersistStorage<S, R> = {\r\n        getItem: (name) => {\r\n            const parse = (str: string | null) => {\r\n                if (str === null) {\r\n                    return null\r\n                }\r\n                return JSON.parse(str, options?.reviver) as StorageValue<S>\r\n            }\r\n            const str = storage.getItem(name) ?? null\r\n            if (str instanceof Promise) {\r\n                return str.then(parse)\r\n            }\r\n            return parse(str)\r\n        },\r\n        setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options?.replacer)),\r\n        removeItem: (name) => storage.removeItem(name)\r\n    }\r\n    return persistStorage\r\n}\r\n\r\nexport interface PersistOptions<S, PersistedState = S, PersistReturn = unknown> {\r\n    /** Name of the storage (must be unique) */\r\n    name: string\r\n    /**\r\n     * Use a custom persist storage.\r\n     *\r\n     * Combining `createJSONStorage` helps creating a persist storage\r\n     * with JSON.parse and JSON.stringify.\r\n     *\r\n     * @default createJSONStorage(() => localStorage)\r\n     */\r\n    storage?: PersistStorage<PersistedState, PersistReturn> | undefined\r\n    /**\r\n     * Filter the persisted value.\r\n     *\r\n     * @params state The state's value\r\n     */\r\n    partialize?: (state: S) => PersistedState\r\n    /**\r\n     * A function returning another (optional) function.\r\n     * The main function will be called before the state rehydration.\r\n     * The returned function will be called after the state rehydration or when an error occurred.\r\n     */\r\n    onRehydrateStorage?: (state: S) => ((state?: S, error?: unknown) => void) | void\r\n    /**\r\n     * If the stored state's version mismatch the one specified here, the storage will not be used.\r\n     * This is useful when adding a breaking change to your store.\r\n     */\r\n    version?: number\r\n    /**\r\n     * A function to perform persisted state migration.\r\n     * This function will be called when persisted state versions mismatch with the one specified here.\r\n     */\r\n    migrate?: (persistedState: unknown, version: number) => PersistedState | Promise<PersistedState>\r\n    /**\r\n     * A function to perform custom hydration merges when combining the stored state with the current one.\r\n     * By default, this function does a shallow merge.\r\n     */\r\n    merge?: (persistedState: unknown, currentState: S) => S\r\n\r\n    /**\r\n     * An optional boolean that will prevent the persist middleware from triggering hydration on initialization,\r\n     * This allows you to call `rehydrate()` at a specific point in your apps rendering life-cycle.\r\n     *\r\n     * This is useful in SSR application.\r\n     *\r\n     * @default false\r\n     */\r\n    skipHydration?: boolean\r\n}\r\n\r\ntype PersistListener<S> = (state: S) => void\r\n\r\ntype StorePersist<S, Ps, Pr> = S extends {\r\n    getState: () => infer T\r\n    setState: {\r\n        // capture both overloads of setState\r\n        (...args: infer Sa1): infer Sr1\r\n        (...args: infer Sa2): infer Sr2\r\n    }\r\n}\r\n    ? {\r\n          setState(...args: Sa1): Sr1 | Pr\r\n          setState(...args: Sa2): Sr2 | Pr\r\n          persist: {\r\n              setOptions: (options: Partial<PersistOptions<T, Ps, Pr>>) => void\r\n              clearStorage: () => void\r\n              rehydrate: () => Promise<void> | void\r\n              hasHydrated: () => boolean\r\n              onHydrate: (fn: PersistListener<T>) => () => void\r\n              onFinishHydration: (fn: PersistListener<T>) => () => void\r\n              getOptions: () => Partial<PersistOptions<T, Ps, Pr>>\r\n          }\r\n      }\r\n    : never\r\n\r\ntype Thenable<Value> = {\r\n    then<V>(onFulfilled: (value: Value) => V | Promise<V> | Thenable<V>): Thenable<V>\r\n    catch<V>(onRejected: (reason: Error) => V | Promise<V> | Thenable<V>): Thenable<V>\r\n}\r\n\r\nconst toThenable =\r\n    <Result, Input>(fn: (input: Input) => Result | Promise<Result> | Thenable<Result>) =>\r\n    (input: Input): Thenable<Result> => {\r\n        try {\r\n            const result = fn(input)\r\n            if (result instanceof Promise) {\r\n                return result as Thenable<Result>\r\n            }\r\n            return {\r\n                then(onFulfilled) {\r\n                    return toThenable(onFulfilled)(result as Result)\r\n                },\r\n                catch(_onRejected) {\r\n                    return this as Thenable<any>\r\n                }\r\n            }\r\n        } catch (e: any) {\r\n            return {\r\n                then(_onFulfilled) {\r\n                    return this as Thenable<any>\r\n                },\r\n                catch(onRejected) {\r\n                    return toThenable(onRejected)(e)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nconst persistImpl: PersistImpl = (config, baseOptions) => (set, get, api) => {\r\n    type S = ReturnType<typeof config>\r\n    let options = {\r\n        storage: createJSONStorage<S, void>(() => localStorage),\r\n        partialize: (state: S) => state,\r\n        version: 0,\r\n        merge: (persistedState: unknown, currentState: S) => ({\r\n            ...currentState,\r\n            ...(persistedState as object)\r\n        }),\r\n        ...baseOptions\r\n    }\r\n\r\n    let hasHydrated = false\r\n    const hydrationListeners = new Set<PersistListener<S>>()\r\n    const finishHydrationListeners = new Set<PersistListener<S>>()\r\n    let storage = options.storage\r\n\r\n    if (!storage) {\r\n        return config(\r\n            (...args) => {\r\n                console.warn(\r\n                    `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\r\n                )\r\n                set(...(args as Parameters<typeof set>))\r\n            },\r\n            get,\r\n            api\r\n        )\r\n    }\r\n\r\n    const setItem = () => {\r\n        const state = options.partialize({ ...get() })\r\n        return (storage as PersistStorage<S, unknown>).setItem(options.name, {\r\n            state,\r\n            version: options.version\r\n        })\r\n    }\r\n\r\n    const savedSetState = api.setState\r\n\r\n    api.setState = (state, replace) => {\r\n        savedSetState(state, replace as any)\r\n        return setItem()\r\n    }\r\n\r\n    const configResult = config(\r\n        (...args) => {\r\n            set(...(args as Parameters<typeof set>))\r\n            return setItem()\r\n        },\r\n        get,\r\n        api\r\n    )\r\n\r\n    api.getInitialState = () => configResult\r\n\r\n    // a workaround to solve the issue of not storing rehydrated state in sync storage\r\n    // the set(state) value would be later overridden with initial state by create()\r\n    // to avoid this, we merge the state from localStorage into the initial state.\r\n    let stateFromStorage: S | undefined\r\n\r\n    // rehydrate initial state with existing stored state\r\n    const hydrate = () => {\r\n        if (!storage) return\r\n\r\n        // On the first invocation of 'hydrate', state will not yet be defined (this is\r\n        // true for both the 'asynchronous' and 'synchronous' case). Pass 'configResult'\r\n        // as a backup  to 'get()' so listeners and 'onRehydrateStorage' are called with\r\n        // the latest available state.\r\n\r\n        hasHydrated = false\r\n        hydrationListeners.forEach((cb) => cb(get() ?? configResult))\r\n\r\n        const postRehydrationCallback = options.onRehydrateStorage?.(get() ?? configResult) || undefined\r\n\r\n        // bind is used to avoid `TypeError: Illegal invocation` error\r\n        return toThenable(storage.getItem.bind(storage))(options.name)\r\n            .then((deserializedStorageValue) => {\r\n                if (deserializedStorageValue) {\r\n                    if (\r\n                        typeof deserializedStorageValue.version === 'number' &&\r\n                        deserializedStorageValue.version !== options.version\r\n                    ) {\r\n                        if (options.migrate) {\r\n                            const migration = options.migrate(\r\n                                deserializedStorageValue.state,\r\n                                deserializedStorageValue.version\r\n                            )\r\n                            if (migration instanceof Promise) {\r\n                                return migration.then((result) => [true, result] as const)\r\n                            }\r\n                            return [true, migration] as const\r\n                        }\r\n                        console.error(\r\n                            `State loaded from storage couldn't be migrated since no migrate function was provided`\r\n                        )\r\n                    } else {\r\n                        return [false, deserializedStorageValue.state] as const\r\n                    }\r\n                }\r\n                return [false, undefined] as const\r\n            })\r\n            .then((migrationResult) => {\r\n                const [migrated, migratedState] = migrationResult\r\n                stateFromStorage = options.merge(migratedState as S, get() ?? configResult)\r\n\r\n                set(stateFromStorage as S, true)\r\n                if (migrated) {\r\n                    return setItem()\r\n                }\r\n            })\r\n            .then(() => {\r\n                // TODO: In the asynchronous case, it's possible that the state has changed\r\n                // since it was set in the prior callback. As such, it would be better to\r\n                // pass 'get()' to the 'postRehydrationCallback' to ensure the most up-to-date\r\n                // state is used. However, this could be a breaking change, so this isn't being\r\n                // done now.\r\n                postRehydrationCallback?.(stateFromStorage, undefined)\r\n\r\n                // It's possible that 'postRehydrationCallback' updated the state. To ensure\r\n                // that isn't overwritten when returning 'stateFromStorage' below\r\n                // (synchronous-case only), update 'stateFromStorage' to point to the latest\r\n                // state. In the asynchronous case, 'stateFromStorage' isn't used after this\r\n                // callback, so there's no harm in updating it to match the latest state.\r\n                stateFromStorage = get()\r\n                hasHydrated = true\r\n                finishHydrationListeners.forEach((cb) => cb(stateFromStorage as S))\r\n            })\r\n            .catch((e: Error) => {\r\n                postRehydrationCallback?.(undefined, e)\r\n            })\r\n    }\r\n\r\n    ;(api as StoreApi<S> & StorePersist<StoreApi<S>, S, unknown>).persist = {\r\n        setOptions: (newOptions) => {\r\n            options = {\r\n                ...options,\r\n                ...newOptions\r\n            }\r\n\r\n            if (newOptions.storage) {\r\n                storage = newOptions.storage\r\n            }\r\n        },\r\n        clearStorage: () => {\r\n            storage?.removeItem(options.name)\r\n        },\r\n        getOptions: () => options,\r\n        rehydrate: () => hydrate() as Promise<void>,\r\n        hasHydrated: () => hasHydrated,\r\n        onHydrate: (cb) => {\r\n            hydrationListeners.add(cb)\r\n\r\n            return () => {\r\n                hydrationListeners.delete(cb)\r\n            }\r\n        },\r\n        onFinishHydration: (cb) => {\r\n            finishHydrationListeners.add(cb)\r\n\r\n            return () => {\r\n                finishHydrationListeners.delete(cb)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!options.skipHydration) {\r\n        hydrate()\r\n    }\r\n\r\n    return stateFromStorage || configResult\r\n}\r\n\r\ntype Persist = <\r\n    T,\r\n    Mps extends [StoreMutatorIdentifier, unknown][] = [],\r\n    Mcs extends [StoreMutatorIdentifier, unknown][] = [],\r\n    U = T\r\n>(\r\n    initializer: StateCreator<T, [...Mps, ['zustand/persist', unknown]], Mcs>,\r\n    options: PersistOptions<T, U>\r\n) => StateCreator<T, Mps, [['zustand/persist', U], ...Mcs]>\r\n\r\ndeclare module '../vanilla' {\r\n    interface StoreMutators<S, A> {\r\n        'zustand/persist': WithPersist<S, A>\r\n    }\r\n}\r\n\r\ntype Write<T, U> = Omit<T, keyof U> & U\r\n\r\ntype WithPersist<S, A> = Write<S, StorePersist<S, A, unknown>>\r\n\r\ntype PersistImpl = <T>(\r\n    storeInitializer: StateCreator<T, [], []>,\r\n    options: PersistOptions<T, T>\r\n) => StateCreator<T, [], []>\r\n\r\nexport const persist = persistImpl as unknown as Persist\r\n"],"names":["str"],"mappings":"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"}